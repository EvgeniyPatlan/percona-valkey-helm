## @section Global parameters
global:
  ## Global image registry override. Prepended to all image repositories.
  imageRegistry: ""

nameOverride: ""
fullnameOverride: ""

## Additional labels applied to all resources
commonLabels: {}

## Kubernetes cluster domain
clusterDomain: cluster.local

## @section Deployment mode
## "standalone", "cluster", or "sentinel"
mode: standalone

## @section Image configuration
image:
  repository: perconalab/valkey
  ## Image variant: "rpm" (UBI9) or "hardened" (DHI)
  variant: rpm
  ## Overrides the image tag (default: appVersion for rpm, appVersion-hardened for hardened)
  tag: ""
  pullPolicy: IfNotPresent
  pullSecrets: []
  ## Job image overrides (cluster-init, cluster-scale, cluster-precheck, test-connection).
  ## Defaults to repository:appVersion (always RPM variant for shell tools).
  jobs:
    repository: ""
    tag: ""

## @section Authentication
auth:
  enabled: true
  ## Valkey password (auto-generated if empty)
  password: ""
  ## Use existing Secret (key: valkey-password)
  existingSecret: ""
  ## Mount password as file instead of env var (more secure)
  usePasswordFiles: false
  ## Directory where password file is mounted
  passwordFilePath: /opt/valkey/secrets
  ## Password rotation without pod restart.
  ## Adds a sidecar that watches the password file and hot-reloads Valkey config.
  passwordRotation:
    enabled: false
    ## Poll interval in seconds
    interval: 10
    ## Resources for the password-watcher sidecar
    resources: {}

## @section ACL (Access Control List)
## Multi-user authentication with per-user command and key restrictions.
## Requires auth.enabled=true. The default user password is still managed by auth.password.
acl:
  enabled: false
  ## Existing Secret containing a "users.acl" key with ACL rules.
  ## When set, acl.users is ignored.
  existingSecret: ""
  ## Structured ACL user definitions. Keys are usernames.
  ## The default user is auto-managed â€” do not define it here.
  users: {}
  #   appuser:
  #     permissions: "~app:* +get +set +del"
  #     password: "secretpass"
  #   monitor:
  #     permissions: "+client +info +slowlog +latency +ping"
  #     existingPasswordSecret: "monitor-creds"
  #     passwordKey: "password"

## @section TLS/SSL configuration
tls:
  enabled: false
  ## TLS port (runs alongside plain-text port unless port is set to 0 in config)
  port: 6380
  ## Existing Secret containing TLS certificates.
  ## Must have keys: tls.crt, tls.key, ca.crt
  existingSecret: ""
  ## Mount path for certificate files inside the container
  certMountPath: /etc/valkey/tls
  ## Enable TLS for replication traffic (standalone with replicas or cluster)
  replication: false
  ## Require TLS client authentication: "yes", "no", or "optional"
  authClients: "no"
  ## Disable the non-TLS port entirely (set valkey port to 0)
  disablePlaintext: false
  ## Existing Secret containing DH parameters file (key: dhparams.pem)
  ## for enhanced Diffie-Hellman key exchange security
  dhParamsSecret: ""
  ## Optional cipher suites (TLS 1.2)
  ciphers: ""
  ## Optional cipher suites (TLS 1.3)
  ciphersuites: ""
  ## cert-manager integration
  certManager:
    enabled: false
    ## Issuer or ClusterIssuer reference
    issuerRef:
      name: ""
      kind: Issuer
      group: cert-manager.io
    ## Certificate duration (default 90d)
    duration: 2160h
    ## Renew before expiry
    renewBefore: 360h
    ## Additional DNS names for the certificate
    additionalDnsNames: []

## @section Valkey configuration
config:
  maxmemory: ""
  maxmemoryPolicy: ""
  bind: "0.0.0.0"
  ## Log level: debug, verbose, notice, warning
  logLevel: ""
  ## Enable diskless replication sync (useful when disk I/O is a bottleneck)
  disklessSync: false
  ## Write quorum: minimum number of replicas that must be connected
  ## for the primary to accept writes. 0 = disabled (default).
  minReplicasToWrite: 0
  ## Maximum replication lag (seconds) for a replica to count toward the write quorum.
  minReplicasMaxLag: 10
  ## Additional flags passed via VALKEY_EXTRA_FLAGS env var
  extraFlags: ""
  ## Custom valkey.conf content appended to generated config
  customConfig: ""

## @section Cluster mode settings
cluster:
  replicas: 6
  replicasPerPrimary: 1
  nodeTimeout: 15000
  busPort: 16379
  ## Pre-check safety validation before scale-down operations.
  ## Runs as a pre-upgrade Helm hook Job. Fails the upgrade if scale-down is unsafe.
  precheckBeforeScaleDown: true

## @section Standalone mode settings
standalone:
  replicas: 1
  ## Use a Deployment instead of StatefulSet (cache-only, no persistence needed).
  ## Requires mode=standalone and persistence.enabled=false.
  useDeployment: false
  ## Deployment strategy (only used when useDeployment=true)
  strategy:
    type: RollingUpdate

## @section Sentinel mode settings
## Master-replica topology monitored by Sentinel for automatic failover.
sentinel:
  ## Total Valkey data pods (1 master + N-1 replicas)
  replicas: 3
  ## Sentinel monitor pods (must be odd, minimum 3)
  sentinelReplicas: 3
  ## Sentinel port
  port: 26379
  ## Master set name (clients query Sentinel with this name)
  masterSet: "mymaster"
  ## Quorum: Sentinels that must agree master is down
  quorum: 2
  ## Milliseconds before considering master unreachable
  downAfterMilliseconds: 30000
  ## Failover timeout in milliseconds
  failoverTimeout: 180000
  ## Replicas that can sync with new master simultaneously
  parallelSyncs: 1
  ## Resources for Sentinel pods
  resources: {}
  ## Persistence for Sentinel (usually not needed)
  persistence:
    enabled: false
    size: 1Gi
  ## Scheduling for Sentinel pods
  podAntiAffinityPreset:
    type: ""
    topologyKey: "kubernetes.io/hostname"
  podAnnotations: {}
  podLabels: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}

## @section StatefulSet parameters
statefulset:
  updateStrategy:
    type: RollingUpdate
  podManagementPolicy: ""
  annotations: {}
  labels: {}

## @section Pod parameters
podAnnotations: {}
podLabels: {}

## @section Security context
securityContext:
  runAsUser: 999
  runAsGroup: 999
  fsGroup: 999
  runAsNonRoot: true

containerSecurityContext:
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL

## @section Service parameters
service:
  type: ClusterIP
  port: 6379
  annotations: {}

## @section Persistence
persistence:
  enabled: true
  storageClass: ""
  accessModes:
    - ReadWriteOnce
  size: 8Gi
  annotations: {}

## @section Health probes
livenessProbe:
  enabled: true
  initialDelaySeconds: 20
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  enabled: true
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

startupProbe:
  enabled: true
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 30

## @section Resources
resources:
  limits: {}
  requests: {}

## @section ServiceAccount
serviceAccount:
  create: true
  name: ""
  annotations: {}
  automountServiceAccountToken: false

## @section PodDisruptionBudget (cluster mode only)
pdb:
  enabled: true
  minAvailable: ""
  maxUnavailable: 1

## @section Disable dangerous commands
## Commands listed here are renamed to "" (disabled) in valkey.conf
disableCommands:
  - FLUSHDB
  - FLUSHALL
## Per-mode overrides (optional). If set, these replace disableCommands for that mode.
# disableCommandsStandalone: []
# disableCommandsCluster: []
# disableCommandsSentinel: []

## @section External Access
## Expose Valkey to clients outside the Kubernetes cluster.
## Standalone: changes main service type to LoadBalancer/NodePort.
## Cluster: creates per-pod services + init container for cluster-announce-ip discovery.
externalAccess:
  enabled: false
  service:
    type: LoadBalancer
    port: 6379
    annotations: {}
    loadBalancerSourceRanges: []
    externalTrafficPolicy: Cluster
  ## Standalone-specific overrides
  standalone:
    nodePort: 0
    tlsNodePort: 0
    loadBalancerIP: ""
  ## Cluster-specific overrides (lists indexed by pod ordinal)
  cluster:
    annotations: {}
    nodePorts: []
    tlsNodePorts: []
    busNodePorts: []
    loadBalancerIPs: []

## @section Network Policy
networkPolicy:
  enabled: false
  ## Allow connections from outside the cluster
  allowExternal: true
  ## Additional ingress rules
  extraIngress: []
  ## Additional egress rules
  extraEgress: []

## @section Init containers
## sysctl tuning (requires privileged init container)
sysctlInit:
  enabled: false
  somaxconn: 512
  disableTHP: true
  resources: {}

## Fix volume permissions for PVC (runs as root)
volumePermissions:
  enabled: false
  resources: {}

## @section Metrics (Prometheus exporter)
metrics:
  enabled: false
  image:
    repository: oliver006/redis_exporter
    tag: v1.67.0
    pullPolicy: IfNotPresent
  port: 9121
  resources: {}
  serviceMonitor:
    enabled: false
    namespace: ""
    interval: 30s
    scrapeTimeout: ""
    labels: {}
  podMonitor:
    enabled: false
    namespace: ""
    interval: 30s
    labels: {}
  prometheusRule:
    enabled: false
    namespace: ""
    labels: {}
    ## Example rules:
    # rules:
    #   - alert: ValkeyDown
    #     expr: redis_up == 0
    #     for: 5m
    #     labels:
    #       severity: critical
    #     annotations:
    #       summary: "Valkey instance {{ $labels.instance }} is down"
    rules: []

## @section Graceful failover (cluster mode only)
## Adds a preStop hook that triggers CLUSTER FAILOVER on primary nodes
## before pod shutdown, ensuring zero-downtime rolling updates.
gracefulFailover:
  enabled: true

## @section Lifecycle hooks
## Custom lifecycle hooks. These OVERRIDE the built-in graceful failover preStop.
lifecycle: {}
  # postStart:
  #   exec:
  #     command: ["/bin/sh", "-c", "echo started"]
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "valkey-cli shutdown save"]

## @section Diagnostic mode (overrides entrypoint for debugging)
diagnosticMode:
  enabled: false
  command:
    - sleep
  args:
    - infinity

## @section Extra containers and init containers
## Additional init containers (run before the valkey container starts)
extraInitContainers: []
## Additional sidecar containers (run alongside the valkey container)
extraContainers: []

## @section Extra resources
## Additional volumes to mount on the StatefulSet
extraVolumes: []
## Additional volume mounts for the valkey container
extraVolumeMounts: []
## Simple key-value environment variables for the valkey container.
## For complex env vars (valueFrom, configMapKeyRef), use extraEnvVars.
env: {}
  # TZ: "UTC"
  # MY_CUSTOM_VAR: "value"
## Additional env vars for the valkey container (full spec)
extraEnvVars: []

## @section Resource presets
## Predefined resource configurations. Overridden by explicit resources.limits/requests.
## Options: none, nano, micro, small, medium, large, xlarge
resourcePreset: none

## @section Persistence
## PVC retention policy (requires Kubernetes 1.27+)
persistentVolumeClaimRetentionPolicy:
  whenDeleted: Retain
  whenScaled: Retain

## @section Autoscaling
## Horizontal Pod Autoscaler (standalone mode only, requires metrics-server)
autoscaling:
  hpa:
    enabled: false
    minReplicas: 1
    maxReplicas: 5
    ## Target CPU utilization percentage
    targetCPU: 80
    ## Target memory utilization percentage (optional)
    targetMemory: ""
    ## Custom metrics (optional, overrides targetCPU/targetMemory)
    # customMetrics: []
  ## Vertical Pod Autoscaler (requires VPA controller)
  vpa:
    enabled: false
    ## Update mode: "Off", "Initial", "Auto"
    updateMode: "Auto"
    ## Container policies
    controlledResources:
      - cpu
      - memory
    ## Minimum allowed resources
    minAllowed: {}
    ## Maximum allowed resources
    maxAllowed: {}

## @section Pod scheduling
## Priority class name for pod scheduling priority
priorityClassName: ""

## @section Termination
## Seconds to wait for graceful shutdown before SIGKILL
terminationGracePeriodSeconds: 30

## @section Topology spread constraints
## Control how pods are spread across topology domains (nodes, zones, etc.)
topologySpreadConstraints: []

## @section Pod anti-affinity preset
## Preset anti-affinity rules. Ignored when affinity is set explicitly.
## type: "soft" (preferredDuringScheduling) or "hard" (requiredDuringScheduling)
## topologyKey: e.g. "kubernetes.io/hostname" or "topology.kubernetes.io/zone"
podAntiAffinityPreset:
  type: ""
  topologyKey: "kubernetes.io/hostname"

## @section Runtime class
## Runtime class name for selecting a container runtime (e.g. gVisor, Kata)
runtimeClassName: ""

## @section DNS configuration
## Override the pod DNS policy (default: ClusterFirst)
dnsPolicy: ""
## Custom DNS configuration
dnsConfig: {}
  # nameservers:
  #   - 8.8.8.8
  # searches:
  #   - my-domain.local
  # options:
  #   - name: ndots
  #     value: "5"

## @section Backup
## Scheduled backup via CronJob. Streams RDB dump from Valkey to a backup PVC.
backup:
  enabled: false
  ## Cron schedule (default: 2 AM daily)
  schedule: "0 2 * * *"
  ## Number of RDB backups to retain
  retention: 7
  ## Concurrency policy: Forbid (skip if previous still running), Replace, or Allow
  concurrencyPolicy: Forbid
  ## Pod ordinal that backup connects to (0 = first pod)
  sourceOrdinal: 0
  ## Backup PVC configuration
  storage:
    storageClass: ""
    size: 10Gi
    accessModes:
      - ReadWriteOnce
    existingClaim: ""
  ## Resources for backup container
  resources: {}
  ## Successful/failed job history limits
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1

## @section Node placement
nodeSelector: {}
tolerations: []
affinity: {}
