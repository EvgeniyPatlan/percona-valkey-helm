Percona Valkey has been deployed in {{ .Values.mode }} mode.

{{- $fullname := include "percona-valkey.fullname" . }}

{{- if eq .Values.mode "cluster" }}

Cluster mode: {{ .Values.cluster.replicas }} nodes with {{ .Values.cluster.replicasPerPrimary }} replica(s) per primary.
The cluster-init job will automatically form the cluster after all pods are ready.

To check cluster status:
  kubectl exec -n {{ .Release.Namespace }} {{ $fullname }}-0 -- valkey-cli {{ if .Values.auth.enabled }}-a $(kubectl get secret -n {{ .Release.Namespace }} {{ include "percona-valkey.secretName" . }} -o jsonpath="{.data.valkey-password}" | base64 -d) {{ end }}{{ if .Values.tls.enabled }}-p {{ .Values.tls.port }} --tls --cacert {{ .Values.tls.certMountPath }}/ca.crt {{ end }}cluster info

{{- else if eq .Values.mode "sentinel" }}

Sentinel mode: {{ .Values.sentinel.replicas }} data pods (1 master + {{ sub (int .Values.sentinel.replicas) 1 }} replicas), {{ .Values.sentinel.sentinelReplicas }} Sentinel monitors.
Master set name: {{ .Values.sentinel.masterSet }}

To query the current master:
  kubectl exec -n {{ .Release.Namespace }} {{ $fullname }}-sentinel-0 -- valkey-cli -p {{ .Values.sentinel.port }} {{ if .Values.auth.enabled }}-a $(kubectl get secret -n {{ .Release.Namespace }} {{ include "percona-valkey.secretName" . }} -o jsonpath="{.data.valkey-password}" | base64 -d) {{ end }}{{ if .Values.tls.enabled }}--tls --cacert {{ .Values.tls.certMountPath }}/ca.crt --cert {{ .Values.tls.certMountPath }}/tls.crt --key {{ .Values.tls.certMountPath }}/tls.key {{ end }}SENTINEL get-master-addr-by-name {{ .Values.sentinel.masterSet }}

To check Sentinel status:
  kubectl exec -n {{ .Release.Namespace }} {{ $fullname }}-sentinel-0 -- valkey-cli -p {{ .Values.sentinel.port }} {{ if .Values.auth.enabled }}-a $(kubectl get secret -n {{ .Release.Namespace }} {{ include "percona-valkey.secretName" . }} -o jsonpath="{.data.valkey-password}" | base64 -d) {{ end }}{{ if .Values.tls.enabled }}--tls --cacert {{ .Values.tls.certMountPath }}/ca.crt --cert {{ .Values.tls.certMountPath }}/tls.crt --key {{ .Values.tls.certMountPath }}/tls.key {{ end }}INFO sentinel

To connect to Valkey:

{{- else }}

To connect to Valkey:

{{- end }}

{{- if include "percona-valkey.externalAccessStandalone" . }}

External access is enabled ({{ .Values.externalAccess.service.type }}).

{{- if eq .Values.externalAccess.service.type "LoadBalancer" }}
  export SERVICE_IP=$(kubectl get svc -n {{ .Release.Namespace }} {{ $fullname }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  # If your cloud provider returns a hostname instead:
  # export SERVICE_IP=$(kubectl get svc -n {{ .Release.Namespace }} {{ $fullname }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
{{- else if eq .Values.externalAccess.service.type "NodePort" }}
  export NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
  export NODE_PORT=$(kubectl get svc -n {{ .Release.Namespace }} {{ $fullname }} -o jsonpath='{.spec.ports[?(@.name=="valkey")].nodePort}')
{{- end }}
  {{- if .Values.auth.enabled }}
  export VALKEY_PASSWORD=$(kubectl get secret -n {{ .Release.Namespace }} {{ include "percona-valkey.secretName" . }} -o jsonpath="{.data.valkey-password}" | base64 -d)
  {{- if eq .Values.externalAccess.service.type "LoadBalancer" }}
  valkey-cli -h $SERVICE_IP -p {{ .Values.externalAccess.service.port }} -a $VALKEY_PASSWORD
  {{- else }}
  valkey-cli -h $NODE_IP -p $NODE_PORT -a $VALKEY_PASSWORD
  {{- end }}
  {{- else }}
  {{- if eq .Values.externalAccess.service.type "LoadBalancer" }}
  valkey-cli -h $SERVICE_IP -p {{ .Values.externalAccess.service.port }}
  {{- else }}
  valkey-cli -h $NODE_IP -p $NODE_PORT
  {{- end }}
  {{- end }}

{{- else if include "percona-valkey.externalAccessCluster" . }}

External access is enabled for cluster mode ({{ .Values.externalAccess.service.type }}).
Each pod has a dedicated {{ .Values.externalAccess.service.type }} service for cluster-announce-ip discovery.

{{- if eq .Values.externalAccess.service.type "LoadBalancer" }}
To list external IPs:
  for i in $(seq 0 {{ sub (int .Values.cluster.replicas) 1 }}); do
    echo "{{ $fullname }}-$i: $(kubectl get svc -n {{ .Release.Namespace }} {{ $fullname }}-$i -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
  done
{{- else if eq .Values.externalAccess.service.type "NodePort" }}
To list external NodePorts:
  for i in $(seq 0 {{ sub (int .Values.cluster.replicas) 1 }}); do
    echo "{{ $fullname }}-$i: $(kubectl get svc -n {{ .Release.Namespace }} {{ $fullname }}-$i -o jsonpath='{.spec.ports[?(@.name=="valkey")].nodePort}')"
  done
{{- end }}

  {{- if .Values.auth.enabled }}
  export VALKEY_PASSWORD=$(kubectl get secret -n {{ .Release.Namespace }} {{ include "percona-valkey.secretName" . }} -o jsonpath="{.data.valkey-password}" | base64 -d)
  {{- end }}

{{- else }}

  export SERVICE_IP=$(kubectl get svc -n {{ .Release.Namespace }} {{ $fullname }} -o jsonpath='{.clusterIP}')
  {{- if .Values.auth.enabled }}
  export VALKEY_PASSWORD=$(kubectl get secret -n {{ .Release.Namespace }} {{ include "percona-valkey.secretName" . }} -o jsonpath="{.data.valkey-password}" | base64 -d)
  {{- if .Values.tls.enabled }}
  valkey-cli -h $SERVICE_IP -p {{ .Values.tls.port }} --tls --cacert <path-to-ca.crt> -a $VALKEY_PASSWORD
  {{- else }}
  valkey-cli -h $SERVICE_IP -p {{ .Values.service.port }} -a $VALKEY_PASSWORD
  {{- end }}
  {{- else }}
  {{- if .Values.tls.enabled }}
  valkey-cli -h $SERVICE_IP -p {{ .Values.tls.port }} --tls --cacert <path-to-ca.crt>
  {{- else }}
  valkey-cli -h $SERVICE_IP -p {{ .Values.service.port }}
  {{- end }}
  {{- end }}

{{- end }}

{{- if .Values.auth.passwordRotation.enabled }}

Password rotation is enabled.
A sidecar watches the password Secret file and hot-reloads Valkey config on change.
To rotate the password without restarting pods:
  kubectl patch secret -n {{ .Release.Namespace }} {{ include "percona-valkey.secretName" . }} -p '{"data":{"valkey-password":"'"$(echo -n 'NEW_PASSWORD' | base64)"'"}}'
The sidecar will detect the change within {{ .Values.auth.passwordRotation.interval }} seconds and update Valkey.
{{- end }}

To run the connection test:
  helm test {{ .Release.Name }} -n {{ .Release.Namespace }}

{{- if .Values.acl.enabled }}

ACL (Access Control List) is enabled.
The default user authenticates with the password from auth.password / auth.existingSecret.
{{- if .Values.acl.existingSecret }}
ACL rules are loaded from existing Secret: {{ .Values.acl.existingSecret }} (key: users.acl)
{{- else if .Values.acl.users }}
ACL rules are rendered from acl.users into the chart Secret (key: users.acl)
{{- end }}

To connect as a custom ACL user:
  valkey-cli -h <host> -p {{ .Values.service.port }} --user <username> --pass <password>
{{- end }}

{{- if .Values.backup.enabled }}

Backup CronJob is enabled.
  Schedule: {{ .Values.backup.schedule }}
  Retention: {{ .Values.backup.retention }} backups
  PVC: {{ .Values.backup.storage.existingClaim | default (printf "%s-backup" $fullname) }}

To list existing backups:
  kubectl exec -n {{ .Release.Namespace }} $(kubectl get pods -n {{ .Release.Namespace }} -l job-name -l app.kubernetes.io/component=backup --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "<backup-pod>") -- ls -lh /backup/

To manually trigger a backup:
  kubectl create job --from=cronjob/{{ $fullname }}-backup {{ $fullname }}-backup-manual -n {{ .Release.Namespace }}

To restore from backup:
  1. Scale down the StatefulSet:
     kubectl scale statefulset {{ $fullname }} -n {{ .Release.Namespace }} --replicas=0
  2. Copy the RDB file to the data PVC (example for pod-0):
     kubectl run restore-helper --image={{ include "percona-valkey.rpmImage" . }} --restart=Never \
       --overrides='{"spec":{"volumes":[{"name":"data","persistentVolumeClaim":{"claimName":"data-{{ $fullname }}-0"}},{"name":"backup","persistentVolumeClaim":{"claimName":"{{ .Values.backup.storage.existingClaim | default (printf "%s-backup" $fullname) }}"}}],"containers":[{"name":"restore","image":"{{ include "percona-valkey.rpmImage" . }}","command":["sh","-c","cp /backup/<backup-file>.rdb /data/dump.rdb && chown 999:999 /data/dump.rdb"],"volumeMounts":[{"name":"data","mountPath":"/data"},{"name":"backup","mountPath":"/backup"}]}]}}' \
       -n {{ .Release.Namespace }}
  3. Scale the StatefulSet back up:
     kubectl scale statefulset {{ $fullname }} -n {{ .Release.Namespace }} --replicas=1
{{- end }}

{{- if .Values.tls.enabled }}

TLS is enabled on port {{ .Values.tls.port }}.
{{- if .Values.tls.disablePlaintext }}
The plain-text port is disabled. All connections require TLS.
{{- else }}
Both plain-text ({{ .Values.service.port }}) and TLS ({{ .Values.tls.port }}) ports are available.
{{- end }}
{{- if .Values.tls.certManager.enabled }}
Certificates are managed by cert-manager (issuer: {{ .Values.tls.certManager.issuerRef.name }}).
{{- else }}
Certificates are provided via Secret: {{ include "percona-valkey.tlsSecretName" . }}
{{- end }}
{{- end }}
